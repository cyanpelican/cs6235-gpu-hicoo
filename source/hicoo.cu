#include "hicoo.hpp"
#include "coo.hpp"


void HicooTensor::freeAllArrays() {
    DEBUG_PRINT("HT: free all arrays\n");
    freeHostArrays();
    freeDeviceArrays();
}
void HicooTensor::freeHostArrays() {
    DEBUG_PRINT("HT: free host arrays\n");
    DEBUG_PRINT("    - points_h = %p\n", points_h);
    DEBUG_PRINT("    - blocks_h = %p\n", blocks_h);
    free(points_h);
    free(blocks_h);
    points_h = nullptr;
    blocks_h = nullptr;
}
void HicooTensor::freeDeviceArrays() {
    DEBUG_PRINT("HT: free device arrays\n");
    DEBUG_PRINT("    - points_d = %p\n", points_d);
    DEBUG_PRINT("    - blocks_d = %p\n", blocks_d);
    if(points_d != nullptr) // Because the docs lie: "If devPtr is 0, no operation is performed."
        cudaErrorCheck(cudaFree(points_d));
    if(blocks_d != nullptr) // Because the docs lie: "If devPtr is 0, no operation is performed."
        cudaErrorCheck(cudaFree(blocks_d));
    points_d = nullptr;
    blocks_d = nullptr;
}

void HicooTensor::uploadToDevice() {
    DEBUG_PRINT("HT: upload to device\n");
    assert(points_h != nullptr);
    assert(blocks_h != nullptr);
    freeDeviceArrays();

    cudaErrorCheck(cudaMalloc((void **) &points_d, sizeof(HicooPoint) * numPoints));
    assert(points_d != nullptr);
    cudaErrorCheck(cudaMemcpy(points_d, points_h, sizeof(HicooPoint) * numPoints, cudaMemcpyHostToDevice));

    cudaErrorCheck(cudaMalloc((void **) &blocks_d, sizeof(HicooBlock) * (numBlocks+1)));
    assert(blocks_d != nullptr);
    cudaErrorCheck(cudaMemcpy(blocks_d, blocks_h, sizeof(HicooBlock) * (numBlocks+1), cudaMemcpyHostToDevice));
}

void HicooTensor::downloadToHost() {
    DEBUG_PRINT("HT: download to host\n");
    assert(points_d != nullptr);
    assert(blocks_d != nullptr);
    freeHostArrays();

    points_h = (HicooPoint*)malloc(sizeof(HicooPoint) * numPoints);
    assert(points_h != nullptr);
    cudaErrorCheck(cudaMemcpy(points_h, points_d, sizeof(HicooPoint) * numPoints, cudaMemcpyDeviceToHost));

    blocks_h = (HicooBlock*)malloc(sizeof(HicooBlock) * (numBlocks+1));
    assert(blocks_h != nullptr);
    cudaErrorCheck(cudaMemcpy(blocks_h, blocks_d, sizeof(HicooBlock) * (numBlocks+1), cudaMemcpyDeviceToHost));
}


CooTensorManager HicooTensor::toCoo() {
    DEBUG_PRINT("HT: to coo\n");
    CooTensorManager ret;
    assert(0); // TODO
    return ret;
}


DenseMatrixManager HicooTensor::mttkrp_naive_cpu(DenseMatrix d, DenseMatrix c) {
    DenseMatrixManager ret;
    assert(this->points_h != nullptr);
    assert(points_h != nullptr);
    assert(blocks_h != nullptr);


    // see the same method in coo.cu for a detailed comment about the details of this computation

    // A(i,j) = B(i,k,l) * D(l,j) * C(k,j);


    //order of dimensions goes height, width , depth
    //todo: double check this. It might be x,y,z: width, height, depth

    //check for compatible dimensions
    assert(this->width == d.width);
    assert(this->depth == c.width);

    // tensor: i x k x l
    // matrix1: j x k
    // matrix2: j x l
    // result: j x i

    // Generated by the Tensor Algebra Compiler (tensor-compiler.org)
    // for (int32_t pA = 0; pA < (A1_dimension * A2_dimension); pA++) {
    //     A_vals[pA] = 0.0;
    // }
    // for (int32_t pB1 = B1_pos[0]; pB1 < B1_pos[1]; pB1++) {
    //     int32_t iB = B1_coord[pB1];
    //     for (int32_t pB2 = B2_pos[pB1]; pB2 < B2_pos[(pB1 + 1)]; pB2++) {
    //         int32_t kB = B2_coord[pB2];
    //         for (int32_t pB3 = B3_pos[pB2]; pB3 < B3_pos[(pB2 + 1)]; pB3++) {
    //             int32_t lB = B3_coord[pB3];
    //             double tl = B_vals[pB3];
    //             for (int32_t jC = 0; jC < C2_dimension; jC++) {
    //                 int32_t pC2 = kB * C2_dimension + jC;
    //                 int32_t pD2 = lB * D2_dimension + jC;
    //                 int32_t pA2 = iB * A2_dimension + jC;
    //                 A_vals[pA2] = A_vals[pA2] + tl * C_vals[pC2] * D_vals[pD2];
    //                 //my version:
    //                 *ret.tensor->tensor.access(i,j) = *ret.tensor->tensor.access(i,j) + this->access(i,k,l) * d.access(l,j) * c.access(k,j);
    //             }
    //         }
    //     }
    // }


    //A(i,j) = B(i,k,l) * C(k,j) * D(l,j)
//
//    for (unsigned int i = 0; i < this->height; i++) {
//        for (unsigned int k = 0; k < this->width; k++) {
//            for (unsigned int l = 0; l < this->depth; l++) {
//                for (unsigned int j = 0; j < d.height; j++) {
//                    ret.tensor->tensor.access(i,j) = ret.tensor->tensor.access(i,j) + this->access(i,k,l) * d.access(l,j) * c.access(k,j);
//                }
//            }
//        }
//    }

    return ret;
}

DenseMatrixManager HicooTensor::mttkrp_naive_gpu(DenseMatrix d, DenseMatrix c) {
    DenseMatrixManager ret;
    assert(points_d != nullptr);
    assert(blocks_d != nullptr);

    // TODO
    assert(0);

    // A(i,j) = B(i,k,l) * D(l,j) * C(k,j);

    return ret;
}

DenseMatrixManager HicooTensor::mttkrp_fast(DenseMatrix d, DenseMatrix c) {
    DenseMatrixManager ret;

    // TODO
    assert(0);

    // A(i,j) = B(i,k,l) * D(l,j) * C(k,j);

    return ret;
}
